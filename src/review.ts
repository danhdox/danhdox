import * as core from '@actions/core';
import OpenAI from 'openai';
import { GitHubClient, PRFile } from './github';
import { formatReviewPrompt } from './prompts';

export interface PRReviewResult {
  summary: string;
  risk_level: 'low' | 'medium' | 'high';
  missing_elements: string[];
  design_alignment: 'aligned' | 'partially_aligned' | 'misaligned';
  readiness_score: number;
}

export async function reviewPullRequest(
  openai: OpenAI,
  client: GitHubClient,
  prNumber: number,
  prTitle: string,
  prDescription: string,
  additions: number,
  deletions: number,
  changedFiles: number,
  files: PRFile[]
): Promise<PRReviewResult> {
  try {
    // Generate diff summary
    const diffSummary = generateDiffSummary(files);

    // Call LLM for review
    const prompt = formatReviewPrompt(
      prTitle,
      prDescription,
      changedFiles,
      additions,
      deletions,
      diffSummary
    );

    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: 'You are an expert code reviewer providing structured feedback on pull requests.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.2,
      response_format: { type: 'json_object' }
    });

    const content = response.choices[0].message.content || '{}';
    const result = JSON.parse(content);

    // Validate and return
    return {
      summary: result.summary || 'No summary available',
      risk_level: result.risk_level || 'medium',
      missing_elements: Array.isArray(result.missing_elements) ? result.missing_elements : [],
      design_alignment: result.design_alignment || 'partially_aligned',
      readiness_score: result.readiness_score || 50
    };
  } catch (error) {
    core.error(`Failed to review PR: ${error}`);
    // Return default review
    return {
      summary: 'Review failed',
      risk_level: 'medium',
      missing_elements: [],
      design_alignment: 'partially_aligned',
      readiness_score: 50
    };
  }
}

function generateDiffSummary(files: PRFile[]): string {
  const MAX_FILES_DETAIL = 20;
  const summary: string[] = [];

  // Group files by type
  const filesByExtension: Record<string, number> = {};
  const filePaths: string[] = [];

  for (const file of files) {
    filePaths.push(file.filename);
    
    const ext = file.filename.split('.').pop() || 'unknown';
    filesByExtension[ext] = (filesByExtension[ext] || 0) + 1;
  }

  // Add file type distribution
  const extensions = Object.entries(filesByExtension)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5);
  
  summary.push('File types:');
  for (const [ext, count] of extensions) {
    summary.push(`- ${ext}: ${count} files`);
  }

  // Add file details (limited)
  if (files.length <= MAX_FILES_DETAIL) {
    summary.push('\nChanged files:');
    for (const file of files.slice(0, MAX_FILES_DETAIL)) {
      summary.push(`- ${file.filename} (+${file.additions}/-${file.deletions})`);
    }
  } else {
    summary.push(`\nTotal files changed: ${files.length} (showing top ${MAX_FILES_DETAIL})`);
    for (const file of files.slice(0, MAX_FILES_DETAIL)) {
      summary.push(`- ${file.filename} (+${file.additions}/-${file.deletions})`);
    }
  }

  return summary.join('\n');
}

export function formatReviewComment(result: PRReviewResult): string {
  const lines: string[] = [];

  lines.push('## ðŸ¤– AI Triage Review\n');
  lines.push('### Summary');
  lines.push(result.summary);
  lines.push('');
  
  lines.push('### Analysis');
  lines.push(`**Risk Level:** ${getRiskEmoji(result.risk_level)} ${result.risk_level.toUpperCase()}`);
  lines.push(`**Design Alignment:** ${result.design_alignment.replace('_', ' ')}`);
  lines.push(`**Readiness Score:** ${result.readiness_score}/100`);
  lines.push('');

  if (result.missing_elements.length > 0) {
    lines.push('### Missing Elements');
    for (const element of result.missing_elements) {
      lines.push(`- ${element}`);
    }
    lines.push('');
  }

  lines.push('### Recommended Labels');
  const labels = getRecommendedLabels(result);
  if (labels.length > 0) {
    for (const label of labels) {
      lines.push(`- \`${label}\``);
    }
  } else {
    lines.push('- No additional labels recommended');
  }

  lines.push('');
  lines.push('---');
  lines.push('*This review was automatically generated by AI Triage Action*');

  return lines.join('\n');
}

function getRiskEmoji(risk: string): string {
  switch (risk) {
    case 'low':
      return 'âœ…';
    case 'medium':
      return 'âš ï¸';
    case 'high':
      return 'ðŸ”´';
    default:
      return 'â“';
  }
}

function getRecommendedLabels(result: PRReviewResult): string[] {
  const labels: string[] = [];

  if (result.missing_elements.includes('tests')) {
    labels.push('needs-tests');
  }

  if (result.risk_level === 'high') {
    labels.push('high-risk');
  }

  if (result.readiness_score >= 80) {
    labels.push('ready-for-review');
  }

  return labels;
}
